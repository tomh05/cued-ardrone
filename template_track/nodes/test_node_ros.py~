#!/usr/bin/env python

import roslib; roslib.load_manifest('test_node')
import rospy
import ardrone_autonomy.msg
from sensor_msgs.msg import Image
import cv2 
from cv_bridge import CvBridge
import numpy
import math

end = None

def navdata(d): 
	#print d.rotX
	pass

def process_frame(cimg, end):
	grey = cv2.cvtColor(cimg, cv2.COLOR_BGR2GRAY)

	b_enb = cv2.getTrackbarPos('B enable', 'sliders')
	thresh = cv2.getTrackbarPos('B thresh', 'sliders')
	thrs1 = cv2.getTrackbarPos('C thrs1', 'sliders')
	thrs2 = cv2.getTrackbarPos('C thrs2', 'sliders')
	g_enb = cv2.getTrackbarPos('G enable', 'sliders')
	sigma = cv2.getTrackbarPos('G sigma', 'sliders')/10.0
	if sigma == 0:
		cv2.setTrackbarPos('G sigma', 'sliders', 1)
	sigma = 0.1
	minlength = cv2.getTrackbarPos('H minlen', 'sliders')
	maxgap = cv2.getTrackbarPos('H maxgap', 'sliders')


	if b_enb == 1:
		retval, binary = cv2.threshold(grey, thresh, 255, cv2.THRESH_BINARY)
		edges = cv2.Canny(binary, thrs1, thrs2)
	else:
		edges = cv2.Canny(grey, thrs1, thrs2)

	if g_enb == 1:
		edges = cv2.GaussianBlur(edges, (0,0), sigma)

	cv2.namedWindow('edgesBlur')
	cv2.imshow('edgesBlur', edges)

	seq, heirarchy=cv2.findContours(edges, cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)

	cimg2 = cimg.copy()
	cv2.drawContours(cimg2, seq, -1, (0, 255, 0))
	#cv2.namedWindow('display')
	#cv2.imshow('display', cimg2)
	#cv2.waitKey(5)

	#cimg2 = cimg.copy()
	seq_ext, hierarchy = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
	cv2.drawContours(cimg2, seq_ext, -1, (255, 0, 0))
	cv2.namedWindow('display2')
	cv2.imshow('display2', cimg2)

	sqrs = []

	cimg2 = cimg.copy()
	for s in seq:
		#do not take into account external countours
		if not(s==list(seq_ext)):                               # This is dodgy
		    perim = cv2.arcLength(s, True) #contour perimeter
		    area =cv2.contourArea(s) #contour area      
		    polygon=cv2.approxPolyDP(s,perim*0.02, True)
		    sqr=cv2.boundingRect(polygon)
		    sqrs.append(sqr)
		else:
		    #move on to the next outer contour      
		    seq_ext=seq_ext.h_next()   
		    #h_next: points to sequences on the same level
		    seq=seq.h_next()



	# Get Lines at all angles
	edges = cv2.Canny(grey, thrs1, thrs2)
	cv2.namedWindow('edges')
	cv2.imshow('edges', edges)
	'''
	lines = cv2.HoughLinesP(edges, 1, math.pi/320, 2, None, minlength, maxgap)
	linesa = []
	linesb = []
	linesc = []
	'''
	stags = []
	sqrs2 = []
	sqrs4 = []



	# Filter squares
	for i, s in enumerate(sqrs):
		# Wrong proportions
		if s[2]<s[3] and 1.5*s[2]>s[3] and s[2] > 32 and s[2] < 320 - 16 and s[3]>32 and s[3] < 240 - 16:
		    if end[0]!=-1:
		        if s[0] > end[0]-32 and s[0] < end[0]+32 and s[1] > end[1]-32 and s[1] < end[1]+32 and s[0]+s[2] > end[0]+end[2]-32 and s[0]+s[2] < end[0]+end[2]+32 and s[1]+s[3] > end[1]+end[3]-32 and s[1]+s[3] < end[1]+end[3]+32:
		            sqrs2.append(s)
		    else:
		        sqrs2.append(s)
		# Moved too much


	for i, s1 in enumerate(sqrs2):
		for j, s2 in enumerate(sqrs2):
		    if i != j:
			if s1[0] > s2[0] and s1[1] > s2[1] and s1[0]+s1[2] < s2[0]+s2[2] and s1[1]+s1[3] < s2[1]+s2[3]:
			    sqrs4.append(s2)
	sqrs3 = [x for x in sqrs2 if x not in sqrs4]


	best = 999


	endtemp = None

	for s in sqrs3:
		i = ((s[2]/end[2])**2+(s[3]/end[3])**2 -2)**2
	if i < best:
	    best = i
	    #if (i < 2.5) or end[0]==-1:
	    endtemp = s


	'''
	for i, s in enumerate(sqrs2):
	stags.append(0)
	if lines!= None:
	    #Corner a
	    for l in lines[0]:
		# Check aligned in x
		if l[0] < s[0] + 4:
		    if l[0] > s[0] - 4:
		        # Check aligned in y
		        if l[1] < s[1]+s[3] + 4:
		            if l[1] > s[1]+s[3] - 4:
		                linesa.append(l)
		                stags[i]+=stags[i]
	    #Corner b
	    for l in lines[0]:
		# Check aligned in x
		if l[0] < s[0]+s[2] + 4:
		    if l[0] > s[0]+s[2] - 4:
		        # Check aligned in y
		        if l[1] < s[1]+s[3] + 4:
		            if l[1] > s[1]+s[3] - 4:
		                linesb.append(l)
		                stags[i]+=stags[i]              
	'''


	cimg2 = cimg.copy()
	for sqr in sqrs:
		pt1 = (sqr[0],sqr[1])
		pt2 = (sqr[0]+sqr[2],sqr[1]+sqr[3])
		cv2.rectangle(cimg2, pt1, pt2, (0,0,0), 1)


	for sqr in sqrs2:
		pt1 = (sqr[0],sqr[1])
		pt2 = (sqr[0]+sqr[2],sqr[1]+sqr[3])
		cv2.rectangle(cimg2, pt1, pt2, (127,127,127), 1)

	for sqr in sqrs3:
		pt1 = (sqr[0],sqr[1])
		pt2 = (sqr[0]+sqr[2],sqr[1]+sqr[3])
		cv2.rectangle(cimg2, pt1, pt2, (200,200,200), 1)

	if endtemp != None:
	    pt1 = (endtemp[0],endtemp[1])
	    pt2 = (endtemp[0]+endtemp[2],endtemp[1]+endtemp[3])
	    cv2.rectangle(cimg2, pt1, pt2, (0,255,255), 1)
	    end = endtemp
	    

	#if lines!= None:
	#    for line in lines[0]:
	#        pt1 = (line[0],line[1])
	#        pt2 = (line[2],line[3])
	#        cv2.line(cimg2, pt1, pt2, (0,255,255), 1)
	'''
	if len(linesa)!= None:
	for line in linesa:
	    pt1 = (line[0],line[1])
	    pt2 = (line[2],line[3])
	    cv2.line(cimg2, pt1, pt2, (255,0,255), 1)

	if len(linesb)!= None:
	for line in linesb:
	    pt1 = (line[0],line[1])
	    pt2 = (line[2],line[3])
	    cv2.line(cimg2, pt1, pt2, (0,255,255), 1)
	'''


	cv2.namedWindow('display3')
	cv2.imshow('display3', cimg2)
	#cv2.imshow('display3', 1)

	ch = cv2.waitKey(5)



def imgproc(d):l
	global end
	if end == None:
		end = [-1,-1,64,64]
	bridge = CvBridge()
	cvimg = bridge.imgmsg_to_cv(d,"bgr8")
	npimg = numpy.asarray(cvimg)
	print "got image"
	cv2.imshow("Output",npimg)
	process_frame(npimg, end)
	cv2.waitKey(1)

def connect():
	rospy.init_node('dronecontroller')
	#rospy.Subscriber('/image_/navdata',ardrone_autonomy.msg.Navdata,navdata)
	rospy.Subscriber('/imageserver/front',Image,imgproc)

def nothing(*arg):
        pass

def setup_trackbars():
	cv2.namedWindow('sliders')
	cv2.resizeWindow('sliders',400,480)
	cv2.createTrackbar('B enable', 'sliders', 0, 1, nothing)
	cv2.createTrackbar('B thresh', 'sliders', 50, 255, nothing)
	cv2.createTrackbar('C thrs1', 'sliders', 50, 500, nothing)
	cv2.createTrackbar('C thrs2', 'sliders', 275, 500, nothing)
	cv2.createTrackbar('G enable', 'sliders', 1, 1, nothing)
	cv2.createTrackbar('G sigma', 'sliders', 5, 250, nothing)
	cv2.createTrackbar('H minlen', 'sliders', 10, 100, nothing)
	cv2.createTrackbar('H maxgap', 'sliders', 2, 100, nothing)
	

def initialise():
	connect()
	setup_trackbars()
	

def run():
	initialise()
	cv2.namedWindow("Output")
	rospy.spin()

if __name__ == '__main__':
	run()










